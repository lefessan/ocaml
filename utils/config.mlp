#2 "utils/config.mlp"
(**************************************************************************)
(*                                                                        *)
(*                                 OCaml                                  *)
(*                                                                        *)
(*             Xavier Leroy, projet Cristal, INRIA Rocquencourt           *)
(*                                                                        *)
(*   Copyright 1996 Institut National de Recherche en Informatique et     *)
(*     en Automatique.                                                    *)
(*                                                                        *)
(*   All rights reserved.  This file is distributed under the terms of    *)
(*   the GNU Lesser General Public License version 2.1, with the          *)
(*   special exception on linking described in the file LICENSE.          *)
(*                                                                        *)
(**************************************************************************)

(* The main OCaml version string has moved to ../VERSION *)
let version = Sys.ocaml_version

module RELOCATABLE = struct
(*
   Find the ocaml library directory relatively to the path of the command.
   We use two strategies:
   * If OPAM_SWITCH_PREFIX is defined, we use it, with "lib/ocaml" appended.
     It should work for packages like ppx_tools that link the compilerlibs
     and call their tool in its build directory, i.e. with a wrong relative
     path to the standard library.
   * Otherwise, it's "../../lib/ocaml" appended to the name of the
     command. We simplify and normalize the filename, hopefully in a
     Windows-compatible way.
*)

  let find_in_path path name =
    if not (Filename.is_implicit name) then
      if Sys.file_exists name then name else raise Not_found
    else begin
      let rec try_dir = function
          [] -> raise Not_found
        | dir::rem ->
            let fullname = Filename.concat dir name in
            if Sys.file_exists fullname then fullname else try_dir rem
      in try_dir path
    end

  (* split a string [s] at every char [c], and return the list of sub-strings *)
  let split s c =
    let len = String.length s in
    let rec iter pos to_rev =
      if pos = len then List.rev ("" :: to_rev) else
        match try
            Some ( String.index_from s pos c )
          with Not_found -> None
        with
          Some pos2 ->
            if pos2 = pos then iter (pos+1) ("" :: to_rev) else
              iter (pos2+1) ((String.sub s pos (pos2-pos)) :: to_rev)
        | None -> List.rev ( String.sub s pos (len-pos) :: to_rev )
    in
    iter 0 []

  let simplify path =
    let rec simplify path rev =
      match path with
      | [] -> List.rev rev
      | ".." :: path ->
          begin
            match rev with
            | [] -> simplify path rev
            | _ :: rev -> simplify path rev
          end
      | "." :: path -> simplify path rev
      | "" :: path -> simplify path rev
      | dir :: path -> simplify path ( dir :: rev )
    in
    simplify path []

  let normalize_filename filename =

    (* make relative path absolute *)
    let filename =
      if Filename.is_relative filename then
        Filename.concat (Sys.getcwd ()) filename
      else
        filename
    in

    (* replace backslashes by slashes *)
    let len = String.length filename in
    let bytes = Bytes.of_string filename in
    for i = 0 to len -1 do
      if filename.[i] = '\\' then
        Bytes.set bytes i '/'
    done;
    let filename = Bytes.to_string bytes in

    (*    Printf.eprintf "normalize %S\n%!" filename; *)

    let path = split filename '/' in
    (*    Printf.eprintf "path: %s\n%!" (String.concat " // " path); *)
    let has_leading_slash = len > 0 && filename.[0] = '/' in
    if has_leading_slash then
      String.concat "/" ("" :: simplify path)
    else
      match path with
      | [] -> assert false
      | partition :: path ->
          String.concat "/" (partition :: simplify path)

  (* When called from the Windows shell, Sys.executable_name is not
     correct, we have to search it again in the PATH to make it
     absolute. *)
  let path_sep = if Sys.win32 then ';' else ':'
  let env_path =
    try
      split (Sys.getenv "PATH") path_sep
    with Not_found -> []

  (*  let () = Printf.eprintf "executable_name=%S\n%!" executable_name *)

  let standard_library_default =
    match Sys.getenv "OPAM_SWITCH_PREFIX" with
    | dirname ->
        Filename.concat dirname "lib/ocaml"
    | exception Not_found ->
        let executable_name =
          let executable_name = Sys.executable_name in
          if Filename.is_implicit executable_name then
            let executable_name =
              if Sys.win32 &&
                 not ( Filename.check_suffix executable_name ".exe" ) then
                executable_name ^ ".exe" else
                executable_name in
            try
              find_in_path env_path executable_name
            with Not_found ->
              executable_name
          else
            executable_name
        in
        normalize_filename
          ( executable_name ^ "/../../lib/ocaml" )
  (*
  let () = Printf.eprintf "standard_library_default=%S\n%!"
      standard_library_default
*)
end

let standard_library_default = RELOCATABLE.standard_library_default
(* let standard_library_default = "%%LIBDIR%%" *)

let standard_library =
  try
    Sys.getenv "OCAMLLIB"
  with Not_found ->
  try
    Sys.getenv "CAMLLIB"
  with Not_found ->
    standard_library_default

let ccomp_type = "%%CCOMPTYPE%%"
let c_compiler = "%%CC%%"
let c_output_obj = "%%OUTPUTOBJ%%"
let c_has_debug_prefix_map = %%CC_HAS_DEBUG_PREFIX_MAP%%
let as_has_debug_prefix_map = %%AS_HAS_DEBUG_PREFIX_MAP%%
let ocamlc_cflags = "%%OCAMLC_CFLAGS%%"
let ocamlc_cppflags = "%%OCAMLC_CPPFLAGS%%"
let ocamlopt_cflags = "%%OCAMLOPT_CFLAGS%%"
let ocamlopt_cppflags = "%%OCAMLOPT_CPPFLAGS%%"
let bytecomp_c_libraries = "%%BYTECCLIBS%%"
(* bytecomp_c_compiler and native_c_compiler have been supported for a
   long time and are retained for backwards compatibility.
   For programs that don't need compatibility with older OCaml releases
   the recommended approach is to use the constituent variables
   c_compiler, ocamlc_cflags, ocamlc_cppflags etc., directly.
*)
let bytecomp_c_compiler =
  c_compiler ^ " " ^ ocamlc_cflags ^ " " ^ ocamlc_cppflags
let native_c_compiler =
  c_compiler ^ " " ^ ocamlopt_cflags ^ " " ^ ocamlopt_cppflags
let native_c_libraries = "%%NATIVECCLIBS%%"
let native_pack_linker = "%%PACKLD%%"
let ranlib = "%%RANLIBCMD%%"
let ar = "%%ARCMD%%"
let mkdll, mkexe, mkmaindll =
  (* @@DRA Cygwin - but only if shared libraries are enabled, which we
     should be able to detect? *)
  if Sys.os_type = "Win32" then
    try
      let flexlink =
        let flexlink = Sys.getenv "OCAML_FLEXLINK" in
        let f i =
          let c = flexlink.[i] in
          if c = '/' then '\\' else c in
        (String.init (String.length flexlink) f) ^ " %%FLEXLINK_FLAGS%%" in
      flexlink,
      flexlink ^ " -exe%%FLEXLINK_LDFLAGS%%",
      flexlink ^ " -maindll"
    with Not_found ->
      "%%MKDLL%%", "%%MKEXE%%", "%%MKMAINDLL%%"
  else
    "%%MKDLL%%", "%%MKEXE%%", "%%MKMAINDLL%%"

let flambda = %%FLAMBDA%%
let with_flambda_invariants = %%WITH_FLAMBDA_INVARIANTS%%
let safe_string = %%FORCE_SAFE_STRING%%
let default_safe_string = %%DEFAULT_SAFE_STRING%%
let windows_unicode = %%WINDOWS_UNICODE%% != 0
let supports_shared_libraries = %%SUPPORTS_SHARED_LIBRARIES%%

let flat_float_array = %%FLAT_FLOAT_ARRAY%%

let afl_instrument = %%AFL_INSTRUMENT%%

let exec_magic_number = "Caml1999X026"
    (* exec_magic_number is duplicated in runtime/caml/exec.h *)
and cmi_magic_number = "Caml1999I026"
and cmo_magic_number = "Caml1999O026"
and cma_magic_number = "Caml1999A026"
and cmx_magic_number =
  if flambda then
    "Caml1999y026"
  else
    "Caml1999Y026"
and cmxa_magic_number =
  if flambda then
    "Caml1999z026"
  else
    "Caml1999Z026"
and ast_impl_magic_number = "Caml1999M026"
and ast_intf_magic_number = "Caml1999N026"
and cmxs_magic_number = "Caml1999D026"
and cmt_magic_number = "Caml1999T026"

let interface_suffix = ref ".mli"

let max_tag = 245
(* This is normally the same as in obj.ml, but we have to define it
   separately because it can differ when we're in the middle of a
   bootstrapping phase. *)
let lazy_tag = 246

let max_young_wosize = 256
let stack_threshold = 256 (* see runtime/caml/config.h *)
let stack_safety_margin = 60

let architecture = "%%ARCH%%"
let model = "%%MODEL%%"
let system = "%%SYSTEM%%"

let asm = "%%ASM%%"
let asm_cfi_supported = %%ASM_CFI_SUPPORTED%%
let with_frame_pointers = %%WITH_FRAME_POINTERS%%
let spacetime = %%WITH_SPACETIME%%
let enable_call_counts = %%ENABLE_CALL_COUNTS%%
let libunwind_available = %%LIBUNWIND_AVAILABLE%%
let libunwind_link_flags = "%%LIBUNWIND_LINK_FLAGS%%"
let profinfo = %%WITH_PROFINFO%%
let profinfo_width = %%PROFINFO_WIDTH%%

let ext_exe = "%%EXE%%"
let ext_obj = "%%EXT_OBJ%%"
let ext_asm = "%%EXT_ASM%%"
let ext_lib = "%%EXT_LIB%%"
let ext_dll = "%%EXT_DLL%%"

let host = "%%HOST%%"
let target = "%%TARGET%%"

let default_executable_name =
  match Sys.os_type with
    "Unix" -> "a.out"
  | "Win32" | "Cygwin" -> "camlprog.exe"
  | _ -> "camlprog"

let systhread_supported = %%SYSTHREAD_SUPPORT%%;;

let flexdll_dirs = [%%FLEXDLL_DIR%%];;

type configuration_value =
  | String of string
  | Int of int
  | Bool of bool

let configuration_variables =
  let p x v = (x, String v) in
  let p_int x v = (x, Int v) in
  let p_bool x v = (x, Bool v) in
[
  p "version" version;
  p "standard_library_default" standard_library_default;
  p "standard_library" standard_library;
  p "ccomp_type" ccomp_type;
  p "c_compiler" c_compiler;
  p "ocamlc_cflags" ocamlc_cflags;
  p "ocamlc_cppflags" ocamlc_cppflags;
  p "ocamlopt_cflags" ocamlopt_cflags;
  p "ocamlopt_cppflags" ocamlopt_cppflags;
  p "bytecomp_c_compiler" bytecomp_c_compiler;
  p "native_c_compiler" native_c_compiler;
  p "bytecomp_c_libraries" bytecomp_c_libraries;
  p "native_c_libraries" native_c_libraries;
  p "native_pack_linker" native_pack_linker;
  p "ranlib" ranlib;
  p "architecture" architecture;
  p "model" model;
  p_int "int_size" Sys.int_size;
  p_int "word_size" Sys.word_size;
  p "system" system;
  p "asm" asm;
  p_bool "asm_cfi_supported" asm_cfi_supported;
  p_bool "with_frame_pointers" with_frame_pointers;
  p "ext_exe" ext_exe;
  p "ext_obj" ext_obj;
  p "ext_asm" ext_asm;
  p "ext_lib" ext_lib;
  p "ext_dll" ext_dll;
  p "os_type" Sys.os_type;
  p "default_executable_name" default_executable_name;
  p_bool "systhread_supported" systhread_supported;
  p "host" host;
  p "target" target;
  p_bool "flambda" flambda;
  p_bool "spacetime" spacetime;
  p_bool "safe_string" safe_string;
  p_bool "default_safe_string" default_safe_string;
  p_bool "flat_float_array" flat_float_array;
  p_bool "afl_instrument" afl_instrument;
  p_bool "windows_unicode" windows_unicode;
  p_bool "supports_shared_libraries" supports_shared_libraries;

  p "exec_magic_number" exec_magic_number;
  p "cmi_magic_number" cmi_magic_number;
  p "cmo_magic_number" cmo_magic_number;
  p "cma_magic_number" cma_magic_number;
  p "cmx_magic_number" cmx_magic_number;
  p "cmxa_magic_number" cmxa_magic_number;
  p "ast_impl_magic_number" ast_impl_magic_number;
  p "ast_intf_magic_number" ast_intf_magic_number;
  p "cmxs_magic_number" cmxs_magic_number;
  p "cmt_magic_number" cmt_magic_number;
]

let print_config_value oc = function
  | String s ->
      Printf.fprintf oc "%s" s
  | Int n ->
      Printf.fprintf oc "%d" n
  | Bool p ->
      Printf.fprintf oc "%B" p

let print_config oc =
  let print (x, v) =
    Printf.fprintf oc "%s: %a\n" x print_config_value v in
  List.iter print configuration_variables;
  flush oc;
;;

let config_var x =
  match List.assoc_opt x configuration_variables with
  | None -> None
  | Some v ->
      let s = match v with
        | String s -> s
        | Int n -> Int.to_string n
        | Bool b -> string_of_bool b
      in
      Some s
